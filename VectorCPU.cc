#include "VectorCPU.h"
#include "Soup.h"
#include <ecolab_epilogue.h>
#include <vector>
using std::vector;
OpTable copy={
  {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15},
  {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15},
  {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15},
  {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15},
  {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15},
  {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15},
  {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15},
  {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15},
  {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15},
  {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15},
  {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15},
  {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15},
  {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15},
  {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15},
  {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15}
};

OpTable cmpl={
  {15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0},
  {15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0},
  {15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0},
  {15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0},
  {15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0},
  {15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0},
  {15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0},
  {15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0},
  {15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0},
  {15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0},
  {15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0},
  {15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0},
  {15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0},
  {15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0},
  {15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0},
  {15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0}
};

OpTable addv={
  {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15},
  {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,0},
  {2,3,4,5,6,7,8,9,10,11,12,13,14,15,0,1},
  {3,4,5,6,7,8,9,10,11,12,13,14,15,0,1,2},
  {4,5,6,7,8,9,10,11,12,13,14,15,0,1,2,3},
  {5,6,7,8,9,10,11,12,13,14,15,0,1,2,3,4},
  {6,7,8,9,10,11,12,13,14,15,0,1,2,3,4,5},
  {7,8,9,10,11,12,13,14,15,0,1,2,3,4,5,6},
  {8,9,10,11,12,13,14,15,0,1,2,3,4,5,6,7},
  {9,10,11,12,13,14,15,0,1,2,3,4,5,6,7,8},
  {10,11,12,13,14,15,0,1,2,3,4,5,6,7,8,9},
  {11,12,13,14,15,0,1,2,3,4,5,6,7,8,9,10},
  {12,13,14,15,0,1,2,3,4,5,6,7,8,9,10,11},
  {13,14,15,0,1,2,3,4,5,6,7,8,9,10,11,12},
  {14,15,0,1,2,3,4,5,6,7,8,9,10,11,12,13},
  {15,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14}
};

OpTable carry={
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1},
  {0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1},
  {0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1},
  {0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1},
  {0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1},
  {0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1},
  {0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1},
  {0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1},
  {0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1},
  {0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1},
  {0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1},
  {0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1},
  {0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
  {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
};  

OpTable* optable[] {&copy,&cmpl,&addv,&carry};
size_t numOps=sizeof(optable)/sizeof(OpTable);

// reference to the global soup
extern Soup& soup;

void VectorCPU::execute(instr_set instr)
{
  int32_t src=registers[instr&0xff], dest=registers[(instr>>9)&0xff];
  if (instr&(1<<8))
    src=soup.get(src); //indirect addressing
  if (instr&(1<<17))
    dest=soup.get(dest); //indirect addressing
  auto opCode=(instr>>18) & 0x3F;
  if (opCode & 0x20) // special op
    doSpecialOp(opCode,instr,src,dest);
  else
    {
      auto& op=*optable[ opCode % numOps ]; // TODO - optimise for power of 2 numOps
      int32_t mask=(instr>>24)&0xF;
      dest = (mask&1)*op[dest&0xFF][src&0xFF]
        | ((mask>>1)&1)*(op[dest&(0xFF<<4)][src&(0xFF<<4)]<<4)
    | ((mask>>2)&1)*(op[dest&(0xFF<<8)][src&(0xFF<<8)]<<8)
    | ((mask>>3)&1)*(op[dest&(0xFF<<12)][src&(0xFF<<12)]<<12);
    }
  dest<<4*((instr>>28)&3); //apply shift bits  
  if (instr&(1<<17))
    soup.set(registers[(instr>>9)&0xff],dest);
  else
    registers[(instr>>9)&0xff]=dest;
  // apply increment/decrement
  if ((instr>>30)&1) registers[(instr>>9)&0xff]++;
  if ((instr>>31)&1) registers[(instr)&0xff]--;
  // increment PC
  registers[0]++;
}

enum class SpecialOp {mal,div,adrf};

void VectorCPU::doSpecialOp(int32_t opCode,instr_set instr, int32_t src,int32_t& dest)
{
  switch (opCode)
    {
    case int(SpecialOp::mal):
      dest=soup.mal(src,cellID);
      return;
    case int(SpecialOp::div):
      //TODO
      return;
    case int(SpecialOp::adrf):
      dest=soup.adr(instr&0xFF,registers[0],1);
      return;
    default:
      return; //undefined - is a nop
    }
}
